import { ITreeNode, ITreeNodeData } from "./interfaces/ITreeNode";
import { IVisitor } from "./interfaces/IVisitor";
type Constructor<T = Object> = new (...a: any[]) => T;
export declare const mixin: <TBase extends Constructor<Object>>(Base?: TBase | undefined) => {
    new <T>(...rest: any[]): {
        parent: ITreeNode<T> | null;
        children: (ITreeNode<T> | null)[];
        addChild(node: ITreeNodeData<T>): this;
        depth(): number;
        findLeaves(): ITreeNodeData<T>[];
        findRoot(): ITreeNodeData<T>;
        hasAncestor(ancestor: ITreeNodeData<T>): boolean;
        removeChild(child: ITreeNodeData<T>): this;
        toArray(): ITreeNodeData<T>[];
        traverse(visitor: IVisitor<T>, rest?: any): this;
    };
    mixin: any;
    addChild<T_1>(node: ITreeNodeData<T_1>, child: ITreeNodeData<T_1>): ITreeNodeData<T_1>;
    depth<T_2>(node: ITreeNodeData<T_2>): number;
    findLeaves<T_3>(node: ITreeNodeData<T_3>): ITreeNodeData<T_3>[];
    findRoot<T_4>(node: ITreeNodeData<T_4>): ITreeNodeData<T_4>;
    hasAncestor<T_5>(node: ITreeNodeData<T_5>, ancestor: ITreeNodeData<T_5>): boolean;
    removeChild<T_6>(node: ITreeNodeData<T_6>, child: ITreeNodeData<T_6>): ITreeNodeData<T_6>;
    toArray<T_7>(node: ITreeNodeData<T_7>): ITreeNodeData<T_7>[];
    traverse<T_8>(node: ITreeNodeData<T_8>, visitor: IVisitor<T_8>, rest?: any): ITreeNodeData<T_8>;
};
export declare const TreeNode: {
    new <T>(...rest: any[]): {
        parent: ITreeNode<T> | null;
        children: (ITreeNode<T> | null)[];
        addChild(node: ITreeNodeData<T>): this;
        depth(): number;
        findLeaves(): ITreeNodeData<T>[];
        findRoot(): ITreeNodeData<T>;
        hasAncestor(ancestor: ITreeNodeData<T>): boolean;
        removeChild(child: ITreeNodeData<T>): this;
        toArray(): ITreeNodeData<T>[];
        traverse(visitor: IVisitor<T>, rest?: any): this;
    };
    mixin: <TBase extends Constructor<Object>>(Base?: TBase | undefined) => {
        new <T_1>(...rest: any[]): {
            parent: ITreeNode<T_1> | null;
            children: (ITreeNode<T_1> | null)[];
            addChild(node: ITreeNodeData<T_1>): this;
            depth(): number;
            findLeaves(): ITreeNodeData<T_1>[];
            findRoot(): ITreeNodeData<T_1>;
            hasAncestor(ancestor: ITreeNodeData<T_1>): boolean;
            removeChild(child: ITreeNodeData<T_1>): this;
            toArray(): ITreeNodeData<T_1>[];
            traverse(visitor: IVisitor<T_1>, rest?: any): this;
        };
        mixin: any;
        addChild<T_2>(node: ITreeNodeData<T_2>, child: ITreeNodeData<T_2>): ITreeNodeData<T_2>;
        depth<T_3>(node: ITreeNodeData<T_3>): number;
        findLeaves<T_4>(node: ITreeNodeData<T_4>): ITreeNodeData<T_4>[];
        findRoot<T_5>(node: ITreeNodeData<T_5>): ITreeNodeData<T_5>;
        hasAncestor<T_6>(node: ITreeNodeData<T_6>, ancestor: ITreeNodeData<T_6>): boolean;
        removeChild<T_7>(node: ITreeNodeData<T_7>, child: ITreeNodeData<T_7>): ITreeNodeData<T_7>;
        toArray<T_8>(node: ITreeNodeData<T_8>): ITreeNodeData<T_8>[];
        traverse<T_9>(node: ITreeNodeData<T_9>, visitor: IVisitor<T_9>, rest?: any): ITreeNodeData<T_9>;
    };
    addChild<T_10>(node: ITreeNodeData<T_10>, child: ITreeNodeData<T_10>): ITreeNodeData<T_10>;
    depth<T_11>(node: ITreeNodeData<T_11>): number;
    findLeaves<T_12>(node: ITreeNodeData<T_12>): ITreeNodeData<T_12>[];
    findRoot<T_13>(node: ITreeNodeData<T_13>): ITreeNodeData<T_13>;
    hasAncestor<T_14>(node: ITreeNodeData<T_14>, ancestor: ITreeNodeData<T_14>): boolean;
    removeChild<T_15>(node: ITreeNodeData<T_15>, child: ITreeNodeData<T_15>): ITreeNodeData<T_15>;
    toArray<T_16>(node: ITreeNodeData<T_16>): ITreeNodeData<T_16>[];
    traverse<T_17>(node: ITreeNodeData<T_17>, visitor: IVisitor<T_17>, rest?: any): ITreeNodeData<T_17>;
};
export {};
