import { ITreeNodeData } from "./interfaces/ITreeNode";
import { IVisitor } from "./interfaces/IVisitor";
type Constructor<T = Object> = new (...a: any[]) => T;
export declare const mixin: <TBase extends Constructor<Object>>(Base?: TBase | ObjectConstructor) => {
    new (...a: any[]): {
        parent: any | null;
        children: (any | null)[];
        addChild(node: ITreeNodeData | null): this;
        depth(): number;
        findLeaves(): any[];
        findRoot(): any;
        hasAncestor(ancestor: any): boolean;
        isLeaf(): boolean;
        removeChild(child: any): this;
        toArray(): any[];
        traversePostorder(visitor: IVisitor<any>, ...rest: any[]): this;
        traversePreorder(visitor: IVisitor<any>, ...rest: any[]): this;
    };
    new (value?: any): {
        parent: any | null;
        children: (any | null)[];
        addChild(node: ITreeNodeData | null): this;
        depth(): number;
        findLeaves(): any[];
        findRoot(): any;
        hasAncestor(ancestor: any): boolean;
        isLeaf(): boolean;
        removeChild(child: any): this;
        toArray(): any[];
        traversePostorder(visitor: IVisitor<any>, ...rest: any[]): this;
        traversePreorder(visitor: IVisitor<any>, ...rest: any[]): this;
    };
    mixin: any;
    addChild<T extends ITreeNodeData>(node: T, child: ITreeNodeData | null): T;
    depth(node: ITreeNodeData): number;
    findLeaves<T_1 extends ITreeNodeData>(node: T_1): T_1[];
    findRoot<T_2 extends ITreeNodeData>(node: T_2): ITreeNodeData;
    hasAncestor(node: ITreeNodeData, ancestor: ITreeNodeData | null): boolean;
    isLeaf(node: ITreeNodeData): boolean;
    removeChild<T_3 extends ITreeNodeData>(node: T_3, child: T_3): T_3;
    toArray<T_4 extends ITreeNodeData>(node: T_4): T_4[];
    traversePostorder<T_5 extends ITreeNodeData>(node: T_5, visitor: IVisitor<T_5>, ...rest: any[]): T_5;
    traversePreorder<T_6 extends ITreeNodeData>(node: T_6, visitor: IVisitor<T_6>, ...rest: any[]): T_6;
};
export declare const TreeNode: {
    new (...a: any[]): {
        parent: any | null;
        children: (any | null)[];
        addChild(node: ITreeNodeData | null): this;
        depth(): number;
        findLeaves(): any[];
        findRoot(): any;
        hasAncestor(ancestor: any): boolean;
        isLeaf(): boolean;
        removeChild(child: any): this;
        toArray(): any[];
        traversePostorder(visitor: IVisitor<any>, ...rest: any[]): this;
        traversePreorder(visitor: IVisitor<any>, ...rest: any[]): this;
    };
    new (value?: any): {
        parent: any | null;
        children: (any | null)[];
        addChild(node: ITreeNodeData | null): this;
        depth(): number;
        findLeaves(): any[];
        findRoot(): any;
        hasAncestor(ancestor: any): boolean;
        isLeaf(): boolean;
        removeChild(child: any): this;
        toArray(): any[];
        traversePostorder(visitor: IVisitor<any>, ...rest: any[]): this;
        traversePreorder(visitor: IVisitor<any>, ...rest: any[]): this;
    };
    mixin: <TBase extends Constructor<Object>>(Base?: TBase | ObjectConstructor) => {
        new (...a: any[]): {
            parent: any | null;
            children: (any | null)[];
            addChild(node: ITreeNodeData | null): this;
            depth(): number;
            findLeaves(): any[];
            findRoot(): any;
            hasAncestor(ancestor: any): boolean;
            isLeaf(): boolean;
            removeChild(child: any): this;
            toArray(): any[];
            traversePostorder(visitor: IVisitor<any>, ...rest: any[]): this;
            traversePreorder(visitor: IVisitor<any>, ...rest: any[]): this;
        };
        new (value?: any): {
            parent: any | null;
            children: (any | null)[];
            addChild(node: ITreeNodeData | null): this;
            depth(): number;
            findLeaves(): any[];
            findRoot(): any;
            hasAncestor(ancestor: any): boolean;
            isLeaf(): boolean;
            removeChild(child: any): this;
            toArray(): any[];
            traversePostorder(visitor: IVisitor<any>, ...rest: any[]): this;
            traversePreorder(visitor: IVisitor<any>, ...rest: any[]): this;
        };
        mixin: any;
        addChild<T extends ITreeNodeData>(node: T, child: ITreeNodeData | null): T;
        depth(node: ITreeNodeData): number;
        findLeaves<T_1 extends ITreeNodeData>(node: T_1): T_1[];
        findRoot<T_2 extends ITreeNodeData>(node: T_2): ITreeNodeData;
        hasAncestor(node: ITreeNodeData, ancestor: ITreeNodeData | null): boolean;
        isLeaf(node: ITreeNodeData): boolean;
        removeChild<T_3 extends ITreeNodeData>(node: T_3, child: T_3): T_3;
        toArray<T_4 extends ITreeNodeData>(node: T_4): T_4[];
        traversePostorder<T_5 extends ITreeNodeData>(node: T_5, visitor: IVisitor<T_5>, ...rest: any[]): T_5;
        traversePreorder<T_6 extends ITreeNodeData>(node: T_6, visitor: IVisitor<T_6>, ...rest: any[]): T_6;
    };
    addChild<T_7 extends ITreeNodeData>(node: T_7, child: ITreeNodeData | null): T_7;
    depth(node: ITreeNodeData): number;
    findLeaves<T_8 extends ITreeNodeData>(node: T_8): T_8[];
    findRoot<T_9 extends ITreeNodeData>(node: T_9): ITreeNodeData;
    hasAncestor(node: ITreeNodeData, ancestor: ITreeNodeData | null): boolean;
    isLeaf(node: ITreeNodeData): boolean;
    removeChild<T_10 extends ITreeNodeData>(node: T_10, child: T_10): T_10;
    toArray<T_11 extends ITreeNodeData>(node: T_11): T_11[];
    traversePostorder<T_12 extends ITreeNodeData>(node: T_12, visitor: IVisitor<T_12>, ...rest: any[]): T_12;
    traversePreorder<T_13 extends ITreeNodeData>(node: T_13, visitor: IVisitor<T_13>, ...rest: any[]): T_13;
};
export {};
